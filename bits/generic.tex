\part{Generic programming}

\section{Generic programming}

\subsection{Type detection}

\begin{frame}{Automatic type detection}{}
  \begin{block}{Automatic type detection in \CC{11} and \CC{14}}
    \lstinline!auto! can be used to automatically detect a type in the following situations.
    \begin{itemize}
    \item
      Variable declaration: the type is determined from the initializer \\
      \lstinline!auto x = 1 + 2;! $\to$ \lstinline!int!
    \item
      Function declaration: the type is the trailing return type \\
      \lstinline!auto func(int x) -> int;! $\to$ \lstinline!int!
    \item
      Function declaration: the type is deduced from its return statement\Since{14} \\
      \lstinline!auto add(int x, double y) \{ return x + y; \}! $\to$ \lstinline!double!
    \item
      Variable declaration with \lstinline!decltype(auto)!: the type is deduced from the initializing expression using the rules for \lstinline!decltype!\Since{14}
    \item
      Function declaration with \lstinline!decltype(auto)!: the type is deduced from the return statement using the rules for \lstinline!decltype!\Since{14}
    \item
      Parameter declaration in a lambda expression (generic lambda)\Since{14} \\
      \lstinline![](auto x) \{ return x + 1; \}!
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}{Automatic type detection}{}
  \begin{block}{Automatic type detection in \CC{17} and \CC{20}}
    \lstinline!auto! can be used to automatically detect a type in the following situations.
    \begin{itemize}
    \item
      Template parameter: the type is deduced from the argument\Since{17} \\
      \lstinline!template<auto Param> class C \{ \};!
    \item
      Structure binding declaration\Since{17} \\
      \lstinline!auto [it, inserted] = dict.insert("Hello");!
    \item
      Function parameter declaration\Since{20} \\
      \lstinline!int sign(auto x) \{ return (x > 0) - (x < 0); \}!
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}{Type of an entity or expression}{}
  \begin{block}{Type of an entity}
    \lstinline!decltype! can be used to inspect the type of an entity:
    \begin{itemize}
    \item
      unparenthesized identifier
    \item
      unparenthesized class member access expression
    \end{itemize}
  \end{block}

  \begin{block}{Type of an expression}
    \lstinline!decltype! can be used to inspect the type of an expression of type \lstinline!T!:
    \begin{itemize}
    \item
      if the expression is an xvalue, then \lstinline!decltype! yields \lstinline!T&&!
    \item
      if the expression is an lvalue, then \lstinline!decltype! yields \lstinline!T&!
    \item
      if the expression is an prvalue, then \lstinline!decltype! yields \lstinline!T!
    \end{itemize}
  \end{block}

  \begin{block}{Warning!}
    For an identifier \lstinline!x!, \lstinline!decltype(x)! and \lstinline!decltype((x))! are often different types.
  \end{block}
\end{frame}

\begin{frame}{Type of an entity or expression}{}
  \begin{example}[Type of an entity or expression]
    \sourceinput{snippets/decltype.cc}
  \end{example}
\end{frame}

% https://herbsutter.com/2013/08/12/gotw-94-solution-aaa-style-almost-always-auto/

\begin{frame}{When to use automatic type detection?}{Two schools}
  \begin{block}{School \#1: Only when necessary and/or convenient}
    \begin{itemize}
    \item
      When the type has no name (e.g. lambda) \\
      \lstinline!auto f = [](int x) \{ return x + 1; \};!
    \item
      When the type is too long (e.g. iterator types) \\
      \lstinline!auto it = dict.find("Toto");!
    \item
      When the type name is redundant with its initializer \\
      \lstinline!auto ptr = std::make_unique<Foo>();!
    \end{itemize}
  \end{block}
  \begin{block}{School \#2: Almost Always Auto}
    Some people advocate for "Almost Always Auto" (AAA), even for simple types
    (e.g. \lstinline!auto i = std::size_t\{0\};! instead of \lstinline!std::size_t i = 0;!)
  \end{block}
  $\to$ Do as you want: be consistent, write readable and maintainable code
\end{frame}


% type traits
%
% SFINAE
%
% https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern
%
% policy based programming

% https://en.cppreference.com/w/cpp/language/dependent_name

% if constexpr
